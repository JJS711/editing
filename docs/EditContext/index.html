<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>EditContext API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' defer class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            github: "w3c/editing"
            ,specStatus:   "ED"
            ,shortName:    "edit-context"
            ,editors:      [{ name: "Shihling Keng",
                               mailto: "shihken@microsoft.com",
                               company: "Microsoft Corporation",
                               w3cid: 126951},
                               { name: "Bo Cupp",
                               mailto: "pcupp@microsoft.com",
                               company: "Microsoft Corporation",
                               w3cid: 126951},]
          ,   wgPublicList: "public-editing-tf"
	  ,   otherLinks: [{
                  key: 'Participate',
                  data: [{
                      value: 'We are on GitHub.',
                      href: 'https://github.com/w3c/editing'
                  }, {
                      value: 'File a bug.',
                      href: 'https://github.com/w3c/editing/issues'
                  }, {
                      value: 'Commit history.',
                      href: 'https://github.com/w3c/editing/commits/gh-pages'
                  }, {
                      value: 'Mailing list.',
                      href: 'http://lists.w3.org/Archives/Public/public-editing-tf/'
                  }]
              }]
          ,   group: "webediting"
          ,   edDraftURI:   "https://w3c.github.io/editing/docs/EditContext/"
          , xref: ["WebIDL"
          , "DOM"
          , "HTML"
          , "geometry-1"]
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>The {{EditContext}} is a new API that allows authors to more directly participate in the text input process.
        </p>
    </section>
    <section id='sotd'>
      <p>
      </p>
    </section>
    <section class="informative">
        <h2>Introduction</h2>
        <section id="background">
            <h3>Background and Motivation</h3>
            <p>Modern operating systems provide mechanisms to produce text in a variety of ways: speech-to-text, virtual keyboards, handwriting recognition and many more.  When an app wants to consume text input from these various sources, it must first provide a view of its currently editable text to the operating system.  The view of editable text provides a common language that apps (having a variety of different document models) and sources of text (having a variety of different input methods) can both understand.  Both the apps and input sources communicate with one another by expressing their desired changes to the state of the common view as an event that the other can handle to facilitate the text input process.</p>
            <p>For the purposes of this document, a producer of text is known as a <dfn>Text Input Client</dfn>.  The view provided by an app which wants to consume text is called a <dfn>Text Edit Context</dfn>.  The service provided by the OS to facilitate the editing of text in the [=Text Edit Context=] by the [=Text Input Clients=] is called a <dfn>Text Input Service</dfn>.</p>
            <figure id="many-input-methods">
                <img src="many-input-methods.svg" alt="">
                <figcaption>Many [=Text Input Clients=] using a [=Text Input Service=] to communicate with many apps through their [=Text Edit Contexts=].</figcaption>
            </figure>
            <p>Here’s a typical flow for the text input process in more detail:</p>
            <ol>
                <li>A user places focus into an editable region of the app.</li>
                <li>The app produces a [=Text Edit Context=] describing its editable region according to the standards set forth by the [=Text Input Service=] and provides that [=Text Edit Context=] to the [=Text Input Service=].</li>
                <li>The [=Text Input Service=] triggers a [=Text Input Client=] to provide some user interface for capturing text input from the user and provides the [=Text Input Client=] the app generated [=Text Edit Context=].</li>
                <li>The [=Text Input Client=] reads the location of selection and nearby text from the [=Text Edit Context=] to help tailor its user experience.</li>
                <li>The [=Text Input Client=] may also read screen coordinates for where the selection and editable region are located so that it can properly position its user interface next to the text being edited.</li>
                <li>The user interacts with the [=Text Input Client=] user interface to input text in some [=Text Input Client=]-specific way.</li>
                <li>The [=Text Input Client=] describes its desired modifications to the text and selection in the [=Text Edit Context=] in response to the user’s input.</li>
                <li>The app handles an event describing the desired modifications to its [=Text Edit Context=] and renders the result to the user.</li>
            </ol>
            <figure id="text-input-process">
                <img src="text-input-process.svg" alt="">
                <figcaption>A sequence diagram illustrating a typical flow for text input.</figcaption>
            </figure>
            <p>Existing user agents handle the details of this text input process so that the author’s responsibility ends at declaring what elements of the document represent an editable region.  Authors express which regions are editable using input elements, textarea elements, contenteditable elements, or by setting the designMode attribute to true to mark an entire document as editable. </p>
            <p>As an editable region of the document is focused, the user agent automatically produces the [=Text Edit Context=] from the contents of the editable region and the position of the selection within it.  When a [=Text Input Client=] produces text, the user agent translates the events against its [=Text Edit Context=] into a set of DOM and style modifications – only some of which are described using existing events that an author can handle. </p>
            <p>Authors that want to produce sophisticated editing experiences may be challenged by the current approach.  If, for example, the text and selection are rendered to a canvas, user agents are unable to produce a [=Text Edit Context=] to drive the text input process.  Authors compensate by resorting to offscreen editable elements, but this approach comes with negative implications for accessibility, it deteriorates the input experience, and requires complex code to synchronize the position of the text in the offscreen editable element with the corresponding text in the canvas. </p>
            <p>With the introduction of this EditContext API, authors can more directly participate in the protocol for text input and avoid the pitfalls described above.</p>
        </section>
        <section id="editcontext-model">
            <h3>The EditContext Model</h3>
            <p>An {{EditContext}} is a JavaScript projection of the [=Text Edit Context=] concept discussed in the previous section. Using an {{EditContext}}, an author can mark a region of the document editable by associating an instance of an {{EditContext}} with an element.</p>
            
            <p>Associating an {{EditContext}} to an element makes that element intrinsically focusable.  When the element is focused, the user agent will use the state of the {{EditContext}} to construct a [=Text Edit Context=] that is provided to the [=Text Input Service=] of the OS:</p>
            <ol>
              <li>Instead of deriving the contents of the [=Text Edit Context=] from the DOM, it will be taken from the {{EditContext.text}} property.</li>
              <li>Instead of deriving the location of selection within that text from the document’s selection, the user agent will use the offsets from the {{EditContext.selectionStart}} and {{EditContext.selectionEnd}} properties.</li>
              <li>Instead of querying the DOM’s associated CSS boxes for the size and position of selection and the editable region of the document, the {{EditContext.selectionBound}} and {{EditContext.displaySurfaceBound}} will be used.</li>
            </ol>

            <p>Using an EditContext, an author can mark a region of the document editable by associating an EditContext object with an element as shown in the example below. </p>
            <aside class="example" title="Associate an EditContext with an Element">
                <pre><xmp><script type="module"> 
    let canvas = document.querySelector("canvas") 
    canvas.editContext = new EditContext() 
    // When the associated element is focused, the EditContext is automatically activated.
    canvas.focus();
</script>
<canvas></canvas></xmp></pre></aside>

            <p>In the example below, the author is using a canvas to draw an editable region that allows the user to input a single line of text rendered with a monospace font.  The text for the editable region is maintained by the author as a String.  The text offsets for the selection in the editable region are maintained by the author as a pair of Numbers: selectionStart and selectionEnd.  The Numbers refer to the count of the number of UTF-16 codepoints to the left of the start and end of the selection respectively.  For the sake of communicating the bounding boxes for the current selection and text to Text Input Services, the author also computes the bounding rectangle in CSS pixels for the text and selection.  The offset of the rectangle is expressed relative to the origin of the canvas element since that is the element to which the author has associated an EditContext.  Since the model for the author’s representation of text and selection location matches the form expected by the EditContext API, the author can simply assign those properties to the EditContext associated with the canvas whenever those values change. </p>

            <aside class="example" title="Using EditContext with editing model and view">
                <pre><xmp><script type="module">
    class EditingModel {  
        constructor(text, selectionStart, selectionEnd) {  
            this.text = text  
            this.selectionStart = selectionStart  
            this.selectionEnd = selectionEnd  
        }  
    }  

    class EditingView {  
        constructor(canvas, model) {  
            this.canvas = canvas 
            this.model = model 
        } 

        render() {  
            // paint the canvas
            let canvasContext2D = this.canvas.getContext("2d");
            canvasContext2D.strokeText(this.model.text);

            // update the EditContext 
            let editContext = this.canvas.editContext  
            editContext.text = this.model.text  
            editContext.selectionStart = this.model.selectionStart  
            editContext.selectionEnd = this.model.selectionEnd  

            // compute offsets from canvas origin for selection and text  
            let selectionBounds = this.computeSelectionBounds()  
            let textBounds = this.computeTextBounds()  

            // selectionBounds and textBounds have x, y, width and height members  
            // so they can be assigned directly to the selectionBounds and textBounds  
            // properties of the EditContext  
            editContext.selectionBounds = selectionBounds  
            editContext.textBounds = textBounds  
        } 

        computeSelectionBounds() { 
            // implementation omitted for brevity 
        } 

        computeTextBounds() { 
            // implementation omitted for brevity 
        } 
    }  

    let canvas = document.querySelector("canvas")   
    canvas.editContext = new EditContext()
    let editingModel = new EditingModel()
    let editingView = new EditingView(canvas, editingModel)

    editingView.render() 
</script>
<canvas></canvas></xmp></pre>
            </aside>

            <p>Building on the previous example, in response to user input, authors should handle the events of both the editable element (in this case a canvas) and the EditContext.  Input events against the DOM continue to describe the user’s intent.  Against the EditContext, the textupdate event describes changes to the text and selection properties of the EditContext.  The textformatupdate event describes changes to the style of the text.  The updates received by the author’s code for text, selection and style changes should be rendered back to the canvas so the user can see what they are typing. </p>
            <aside class="example" title="Event handlers for TextUpdateEvent and TextFormatUpdateEvent">
                <pre><xmp><script>
    class EditingModel {
        updateText(updateRangeStart, updateRangeEnd, updateText) {
            this.text = this.text.substring(0, updateRangeStart) + updateText + this.text.substring(updateRangeEnd)
        }

        updateSelection(newSelectionStart, newSelectionEnd) {
            this.selectionStart = newSelectionStart
            this.selectionEnd = newSelectionEnd
        }

        updateTextFormat(formatRangeStart, formatRangeEnd, underlineStyle) {
            // implementation omitted for brevity
        }
    }

    // When user typing, EditContext will receive textupdate events which can be used to update the editor's model.
    editContext.addEventListener("textupdate", e => {
        editingModel.updateText(e.updateRangeStart, e.updateRangeEnd, e.updatetext)
        editingModel.updateSelection(e.newSelectionStart, e.newSelectionEnd)
        editingView.render()
    });

    // EditContext will also receive textformatupdate event for IME decoration.
    // Ex. thin/thick underline for the "phrase mode" in Japanese IME.
    editContext.addEventListener("textformatupdate", e => {
        editingModel.updateTextFormat(e.formatRangeStart, e.formatRangeEnd, e.underlineStyle);
    });
</script></xmp></pre>
            </aside>

        </section>
        <section id="interactions">
            <h3>Interactions with Other Editing Primitives </h3>
            <p>An author doesn’t have to use a canvas element with an EditContext.  In the example below the author uses a div to establish an editable region of the document and renders the contents into that editable region using various other styled elements, images and text.  This allows the author to leverage other built-in editing primitives from the user agent such as selection and spellcheck. </p>

            <aside class="example" title="How native selection can be leveraged to handle caret navigation.">
                <pre><xmp><script>
    document.addEventListener("selectionchange", e => {
        // Authors are responsible to map the selection from the DOM space to the
        // plain text space. One approach is to use range.toString() to get the plain text
        // before the selection start/end, and use the text length as the selection index.
        let s = document.getSelection()
        let range = document.createRange()
        range.setEnd(s.anchorNode, s.anchorOffset)
        range.setStartBefore(parentContainer)
        let selectionStart = range.toString().length

        range.setEnd(s.focusNode, s.focusOffset)
        range.setStartBefore(parentContainer)
        let selectionEnd = range.toString().length

        // Update model
        editingModel.updateSelection(selectionStart, selectionEnd)
        // Update EditContext
        canvas.editContext.updateSelection(newSelectionStart, newSelectionEnd)
    });
</script></xmp></pre>
            </aside>

            <aside class="example" title="How beforeinput can be used to catch insertReplacementText to apply spelling changes">
                <pre><xmp><script>
    editView.spellcheck = true;
    editView.addEventListener("beforeinput", e => {
        if (e.inputType === "insertReplacementText") { // for spellcheck
            let newText = e.dataTransfer.getData("text");
            let range = e.getTargetRanges()[0];
            let updateRangeStart = range.startOffset
            let updateRangeEnd = range.endOffset

            // Update model
            editingModel.updateText(updateRangeStart, updateRangeEnd, newText)
            let newCaretPosition = updateRangeStart + newText.length
            editingModel.updateSelection(newCaretPosition, newCaretPosition)

            // Update EditContext
            canvas.editContext.updateText(updateRangeStart, updateRangeEnd, newText)
            canvas.editContext.updateSelection(newCaretPosition, newCaretPosition)

            // Update DOM
            editingView.render()
        }
    });
</script></xmp></pre>
            </aside>

            <aside class="example" title="How beforeinput can be used to catch deleteByDrag and insertFromDrop to apply drag and drop changes">
                <pre><xmp><script>
    if (e.inputType === "deleteByDrag") {
        // Update model
        editingModel.updateText(this.selectionStart, this.selectionEnd, "") // remove the selection
        
        // Update EditContext
        canvas.editContext.updateText(this.selectionStart, this.selectionEnd, "")

        // Update DOM
        editingView.render()
    } 
    
    if (e.inputType === "insertFromDrop") {
        newText = e.dataTransfer.getData('text/plain');
        let selection = document.getSelection();
        let caretPosition = selection.anchorOffset;

        // Update model
        editingModel.updateText(caretPosition, caretPosition, newText)
        editingModel.updateSelection(caretPosition, caretPosition + newText.length)

        // Update EditContext
        canvas.editContext.updateText(caretPosition, caretPosition, newText)
        canvas.editContext.updateSelection(caretPosition, caretPosition + newText.length)

        // Update DOM
        editingView.render()
    }
</script></xmp></pre>
            </aside>            

        </section>
    </section>
    <section id="conformance">
        <p>
          This specification defines conformance criteria that apply to a single
          product: the <dfn id="dfn-user-agent">user agent</dfn> that implements the interfaces that
          it contains.
        </p>
        <p>
          Conformance requirements phrased as algorithms or specific steps may be
          implemented in any manner, so long as the end result is equivalent. (In
          particular, the algorithms defined in this specification are intended
          to be easy to follow, and not intended to be performant.)
        </p>
    </section>

    <section data-dfn-for="Element">
        <h2>Extensions to the <dfn>Element</dfn> interface</h2>
        <pre class="idl">
            partial interface Element {
                attribute EditContext? editContext;
           };
        </pre>
        <p class="issue">
            Can EditContext be associated with a disconnected element?
        </p>
        <dfn>editContext</dfn>
        <p>
            An {{EditContext}}, initially null.
        </p>
        <p>An `editContext` is activated when the associated element is focused and deactivated when the element is blurred.</p>
        <p>When an EditContext is activated, user text input MUST NOT modify DOM, instead, below steps should be implemented:</p>
        <ol>
            <li>
                Fire relevant beforeinput event on the focused element. If the beforeinput event is cancelled, abort these steps.
            </li>
            <li>
                Update the `text` of the activated EditContext.
            </li>
            <li>
                Fire compositionstart event on the activated EditContext if it's a start of a composition.
            </li>
            <li>
                Fire textupdate event on the activated EditContext.
            </li>
            <li>
                Fire textformateupdate event on the activated EditContext if it's a composition.
            </li>
            <li>
                Fire compositionend event on the activated EditContext if it's an end of a composition.
            </li>
        </ol>
        <p>When an element has an associated EditContext, it behaves like a contenteditable element (e.g., it will be focusable; it will display editing context menu when right-clicking; it will receive beforeinput events) except that its DOM is not changed when there is text input and it doesn't receive any input events.
        </p>
        <p class="note">
            An EditContext can be associated with multiple elements but only the element that has focus will receive events from step 1 above.
        </p>
    </section>
    <section data-dfn-for="EditContext">
        <h2>The <dfn>EditContext</dfn> Interface</h2>
    <pre class="idl"><xmp>dictionary EditContextInit {
    DOMString text;
    unsigned long selectionStart;
    unsigned long selectionEnd;
};

[Exposed=Window]
interface EditContext : EventTarget {
    constructor(optional EditContextInit options = {});
    undefined updateText(unsigned long updateRangeStart, unsigned long updateRangeEnd,
        DOMString text);
    undefined updateSelection(unsigned long selectionStart, unsigned long selectionEnd);

    undefined updateDisplaySurfaceBound(DOMRect displaySurfaceBound);
    undefined updateSelectionBound(DOMRect selectionBound);
    undefined updateCompositionCharacterBounds(sequence<DOMRect> characterBounds);

    sequence<Element> attachedElements();

    readonly attribute DOMString text;
    readonly attribute unsigned long selectionStart;
    readonly attribute unsigned long selectionEnd;
    readonly attribute unsigned long compositionStart;
    readonly attribute unsigned long compositionEnd;
    readonly attribute boolean isInComposition;
    readonly attribute DOMRect displaySurfaceBound;
    readonly attribute DOMRect selectionBound;
    readonly attribute DOMRect characterBounds;

    // Event handler attributes
    attribute EventHandler ontextupdate;
    attribute EventHandler ontextformatupdate;
    attribute EventHandler oncompositionstart;
    attribute EventHandler oncompositionend;
};</xmp></pre>
        <dl>
            <dt><dfn>text</dfn>, of type {{DOMString}}</dt>
            <dd>Initially empty string.  The plain text view of the editable content.</dd>
            <dt><dfn>selectionStart</dfn>, of type {{unsigned long}}</dt>
            <dd>Initially 0. The start index of the selection.</dd>
            <dt><dfn>selectionEnd</dfn>, of type {{unsigned long}}</dt>
            <dd>Initially 0. The end index of the selection.</dd>
            <dt><dfn>compositionStart</dfn>, of type {{unsigned long}}</dt>
            <dd>Initially 0. The start index of the composition.</dd>
            <dt><dfn>compositionEnd</dfn>, of type {{unsigned long}}</dt>
            <dd>Initially 0. The end index of the composition.</dd>
            <dt><dfn>isInComposition</dfn>, of type {{boolean}}</dt>
            <dd>Initially false. Whether there is a active composition.</dd>
            <dt><dfn>displaySurfaceBound</dfn>, of type {{DOMRect}}</dt>
            <dd>Initially 0s. The bounding box of the display surface where the text is rendered</dd>
            <dt><dfn>selectionBound</dfn>, of type {{DOMRect}}</dt>
            <dd>Initially 0s. The bounding box of the selection.</dd>
            <dt><dfn>characterBounds</dfn>, of type array of {{DOMRect}}</dt>
            <dd>Initially 0s. The bounding boxes of each character in the active composition. The size of the array equals to the number of characters that are in active composition</dd>
            <dt>
                <dfn>updateSelection()</dfn> method
            </dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <ol>
                  <li>
                    If the EditContext is not activated, abort these steps.
                  </li>
                  <li>
                    If start > end, abort these steps.
                  </li>
                  <li>
                    set `selectionStart` to `start`
                  </li>
                  <li>
                    set `selectionEnd` to `end`
                  </li>
                </ol>
               </dd>
            <dt>
                <dfn>updateSelectionBound()</dfn> method
            </dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <ol>
                  <li>
                    If the EditContext is not activated, abort these steps.
                  </li>
                  <li>
                    Set the selection bound to `selectionBound`.
                  </li>
                </ol>
              </dd>
              <dt>
                <dfn>updateDisplaySurfaceBound()</dfn> method
            </dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <ol>
                  <li>
                    If the EditContext is not activated, abort these steps.
                  </li>
                  <li>
                    Set the display surface bound to `displaySurfaceBound`.
                  </li>
                </ol>
              </dd>
              <dt>
                <dfn>updateCompositionCharacterBounds()</dfn> method
            </dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <ol>
                  <li>
                    If the EditContext is not activated, abort these steps.
                  </li>
                  <li>
                    Set the character bounds to `characterBounds`.
                  </li>
                </ol>
              </dd>

            <dt>
                <dfn>updateText()</dfn> method
            </dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <ol>
                  <li>
                    If the EditContext is not activated, abort these steps.
                  </li>
                  <li>
                    Replace the string in the range of `start` and `end` with `newText`.
                  </li>
                </ol>
              </dd>
            <dt>
                <dfn>attachedElements()</dfn> method
            </dt>
              <dd>
                <p>
                    The method returns elements that are associated with the EditContext.
                </p>
              </dd>              
            <dt>
                <dfn>ontextupdate</dfn>
            </dt>
            <dd>
            <p>
                The event handler for {{TextUpdateEvent}}.
            </p>
            </dd>
            <dt>
                <dfn>ontextformatupdate</dfn>
            </dt>
            <dd>
            <p>
                The event handler for {{TextFormatUpdateEvent}}.
            </p>
            </dd>
            <dt>
                <dfn>oncompositionstart</dfn>
            </dt>
            <dd>
            <p>
                The event handler for the compositionstart event.
            </p>
            </dd>
            <dt>
                <dfn>oncompositionend</dfn>
            </dt>
            <dd>
            <p>
                The event handler for the oncompositionend event.
            </p>
            </dd>
        </dl>
    </section>
    <section data-dfn-for="EditContextEvents">
        <h2>EditContext events</h2>
        <section>
            <h3>TextUpdateEvent</h3>
            <pre class="idl"><xmp>dictionary TextUpdateEventInit {
    unsigned long updateRangeStart;
    unsigned long updateRangeEnd;
    DOMString text;
    unsigned long selectionStart;
    unsigned long selectionEnd;
    unsigned long compositionStart;
    unsigned long compositionEnd;
};

[Exposed=Window]
interface TextUpdateEvent : Event {
    constructor(optional TextUpdateEventInit options = {});
    readonly attribute unsigned long updateRangeStart;
    readonly attribute unsigned long updateRangeEnd;
    readonly attribute DOMString text;
    readonly attribute unsigned long selectionStart;
    readonly attribute unsigned long selectionEnd;
    readonly attribute unsigned long compositionStart;
    readonly attribute unsigned long compositionEnd;
};
            </xmp></pre>
            <dl>
                <dt>`updateRangeStart`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
                <dt>`updateRangeEnd`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
                <dt>`updateText`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
                <dt>`newSelectionStart`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
                <dt>`newSelectionEnd`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
            </dl>
        </section>
        <section>
            <h3>TextFormatUpdateEvent</h3>
            <pre class="idl">
                dictionary TextFormatUpdateEventInit {
                    unsigned long formatRangeStart;
                    unsigned long formatRangeEnd;
                    DOMString underlineColor;
                    DOMString backgroundColor;
                    DOMString suggestionHighlightColor;
                    DOMString textColor;
                    DOMString underlineThickness;
                    DOMString underlineStyle;
                };
                
                [Exposed=Window]
                interface TextFormatUpdateEvent : Event {
                    constructor(optional TextFormatUpdateEventInit options = {});
                    readonly attribute unsigned long formatRangeStart;
                    readonly attribute unsigned long formatRangeEnd;
                    readonly attribute DOMString underlineColor;
                    readonly attribute DOMString backgroundColor;
                    readonly attribute DOMString suggestionHighlightColor;
                    readonly attribute DOMString textColor;
                    readonly attribute DOMString underlineThickness;
                    readonly attribute DOMString underlineStyle;
                };
            </pre>
            <dl>
                <dt>`formatRangeStart`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
                <dt>`formatRangeEnd`, of type unsigned long, readonly
                </dt>
                <dd>Initially 0.
                </dd>
                <dt>`underlineColor`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
                <dt>`suggestionHighlightColor`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
                <dt>`textColor`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
                <dt>`underlineThickness`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
                <dt>`underlineStyle`, of type {{DOMString}}, readonly
                </dt>
                <dd>Initially empty string.
                </dd>
            </dl>
        </section>
    </section>
    <section>
        <h2>Privacy and Security Considerations</h2>
        <p>To mitigate potential security and privacy risks, browsers are expected to follow best practices described below.</p>
            <p>
                <ul>
                    <li>
                        User Agent MUST only allow {{EditContext/updateSelection()}}, {{EditContext/updateText()}}, {{EditContext/updateSelectionBound()}}, {{EditContext/updateDisplaySurfaceBound()}}, and {{EditContext/updateCompositionCharacterBounds()}} methods to be called in a <a href="https://w3c.github.io/webappsec-secure-contexts/">Secure Context</a>.
                    </li>
                    <li>
                        User Agent MUST only allow {{EditContext/text}}, {{EditContext/selectionStart}}, and {{EditContext/selectionEnd}} to be set in a <a href="https://w3c.github.io/webappsec-secure-contexts/">Secure Context</a>.
                    </li>
                </ul>
            </p>
    </section>
    <section id="idl-index" class="appendix">
        <!-- All the Web IDL will magically appear here -->
    </section>
    <section>
        <h2>Contributors</h2>
        <p class="ednote">
            Add contributors
        </p>
      </section>
      <section id="references" class="appendix"></section>
</body>

</html>
